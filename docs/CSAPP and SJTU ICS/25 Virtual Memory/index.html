<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-CSAPP and SJTU ICS/25 Virtual Memory" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">25 Virtual Memory | Welcome to Keyist&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://key4127.github.io/img/cat-programming-32x32.png"><meta data-rh="true" name="twitter:image" content="https://key4127.github.io/img/cat-programming-32x32.png"><meta data-rh="true" property="og:url" content="https://key4127.github.io/docs/CSAPP and SJTU ICS/25 Virtual Memory"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="25 Virtual Memory | Welcome to Keyist&#x27;s blog"><meta data-rh="true" name="description" content="虚拟内存"><meta data-rh="true" property="og:description" content="虚拟内存"><link data-rh="true" rel="icon" href="/img/cat-programming-32x32.png"><link data-rh="true" rel="canonical" href="https://key4127.github.io/docs/CSAPP and SJTU ICS/25 Virtual Memory"><link data-rh="true" rel="alternate" href="https://key4127.github.io/docs/CSAPP and SJTU ICS/25 Virtual Memory" hreflang="en"><link data-rh="true" rel="alternate" href="https://key4127.github.io/docs/CSAPP and SJTU ICS/25 Virtual Memory" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Welcome to Keyist&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Welcome to Keyist&#39;s blog Atom Feed">




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.ac183f09.css">
<script src="/assets/js/runtime~main.5c44e52d.js" defer="defer"></script>
<script src="/assets/js/main.c5bc1902.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/cat-programming-32x32.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/cat-programming-32x32.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a class="navbar__item navbar__link" href="/docs/intro">Blog</a><a class="navbar__item navbar__link" href="/blog">About Me</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/key4127" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><main class="docMainContainer_TBSr docMainContainerEnhanced_lQrH"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>25 Virtual Memory</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="虚拟内存">虚拟内存<a href="#虚拟内存" class="hash-link" aria-label="Direct link to 虚拟内存" title="Direct link to 虚拟内存">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="访问内存">访问内存<a href="#访问内存" class="hash-link" aria-label="Direct link to 访问内存" title="Direct link to 访问内存">​</a></h3>
<p>从零到最大内存空间，代表实际的物理内存位置。物理访问指CPU通过物理地址访问内存。</p>
<p>虚拟访问指CPU通过虚拟地址访问内存。虚拟地址会被转换为对应的物理地址。转换时涉及到MMU（内存管理单元 ，是CPU的部件，通过SW进行地址翻译）和SW（内存中的表，被操作系统设置，用于查询）。</p>
<p>n位地址空间指空间从0到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span>。每个物理内存可以有一个物理地址和多个虚拟地址，多个进程可以通过共用物理地址通信。</p>
<p>使用虚拟内存可以更高效地使用内存，内存被视作了一种缓存，节约内存空间；内存布局和管理会变得简单；操作系统可以将各个进程的物理空间隔离。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="分页">分页<a href="#分页" class="hash-link" aria-label="Direct link to 分页" title="Direct link to 分页">​</a></h3>
<p>虚拟内存和物理内存都会被分为一个个连续的页（大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">2^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span>，通常为4K），分别被称为VP和PP。VP和PP的大小相同，每个地址一一对应。页表中记录了VP到PP的映射，以及这一页是否存在（valid）。</p>
<p>页表数量和进程数相等。操作系统一个寄存器获取页表基地址。</p>
<p>虚拟内存中分为未分配、缓存、未被缓存三种情况。未分配和未被缓存都会触发page fault，但未被缓存触发后，操作系统会将数据从磁盘搬运到内存，访问可以继续进行。</p>
<p>翻译成功为page hit（valid位为1），否则为page fault。page fault分为三种情况：第一种情况，所需的数据被放在磁盘中，操作系统将磁盘中的数据搬运到内存（swap in/page in）；第二种情况中，数据本来就位于磁盘，同样需要操作系统搬运数据进行按需搬运（demand paging），或者程序要求了空间但操作系统还未分配（例如堆）；第三种情况是segmentation fault。</p>
<p>实际处理page fault的过程分为三步。第一步，processer signal controller将磁盘中的数据搬运到内存。第二部，在I/O控制器的管理下，DMA读取内存。第三步，I/O通过信号通知处理器，读取已经完成。</p>
<p>在某个时间段，程序访问的固定一部分虚拟页称为working set。只要working set小于主内存的总量，局部性就会让系统性能表现得很好，否则就会出现thrashing问题，导致性能下降。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存管理">内存管理<a href="#内存管理" class="hash-link" aria-label="Direct link to 内存管理" title="Direct link to 内存管理">​</a></h3>
<p>虚拟内存可以简化链接和加载，因为对每个进程来说虚拟地址都是独立的，数据、栈、堆等等可以排布在任意位置（比如相同位置）。加载时，为数据段和代码段创建PTE，但是都标为invalid。</p>
<p>此外，对于连续的虚拟页，操作系统可以分配离散的物理页。在不同时刻，一个虚拟页可以指向不同的物理页。此外，不同的虚拟页也可以指向相同的物理页（例如，所有的共享库可以指向相同的位置）。</p>
<p>32位机器的PTE为4位，64位机器为8位（与支持的物理地址范围匹配）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存隔离">内存隔离<a href="#内存隔离" class="hash-link" aria-label="Direct link to 内存隔离" title="Direct link to 内存隔离">​</a></h3>
<p>在地址、是否有效之外，页表中剩余的位置可以存储权限（读、写、执行）。page fault时，会检查权限，如果权限不足会返回segmentation fault。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="地址翻译">地址翻译<a href="#地址翻译" class="hash-link" aria-label="Direct link to 地址翻译" title="Direct link to 地址翻译">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="基本信息">基本信息<a href="#基本信息" class="hash-link" aria-label="Direct link to 基本信息" title="Direct link to 基本信息">​</a></h3>
<p>翻译时，CPU核心给出的所有地址均被视作虚拟地址。</p>
<p>定义一些基本参数：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><mtext>虚拟地址上限</mtext></mrow><annotation encoding="application/x-tex">N = 2^n = 虚拟地址上限</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord cjk_fallback">虚拟地址上限</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup><mo>=</mo><mtext>物理地址上限</mtext></mrow><annotation encoding="application/x-tex">M = 2^m = 物理地址上限</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">M</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord cjk_fallback">物理地址上限</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><msup><mn>2</mn><mi>p</mi></msup><mo>=</mo><mtext>页大小（单位为字节，通常</mtext><mi>p</mi><mo>=</mo><mn>12</mn><mtext>，</mtext><mi>P</mi><mo>=</mo><mn>4</mn><mi>K</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">P = 2^p = 页大小（单位为字节，通常p = 12， P = 4K）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord cjk_fallback">页大小（单 位为字节，通常</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">12</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.07153em">K</span><span class="mord cjk_fallback">）</span></span></span></span></p>
<p>虚拟地址和物理地址都分为虚拟/物理地址数（VPN/PPN）和页偏移（VPO/PPO）两个部分。页偏移均为p位，且翻译过程中不会更改。实际翻译的过程是将VPN翻译为PPN。</p>
<p>页表也存在物理内存中。CR3寄存器中存放物理地址。</p>
<p>翻译时，后p位不变，在表中找出前n-p位对应的物理地址，填充到m-p位中，就获得完整的物理地址。</p>
<p>对于page hit的情况，MMU需要访问两次物理内存，分别用于查找页表和查找实际的数据。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="缓存">缓存<a href="#缓存" class="hash-link" aria-label="Direct link to 缓存" title="Direct link to 缓存">​</a></h3>
<p>如果通过VA访问缓存，CPU可以直接访问；否则CPU需要将指令交给MMU解析，前者更快。但现在大多数缓存通过PA索引。每个进程的地址空间是独立的，对应不同的页表，切换时如果不清空cache，就会导致cache中的地址仍然是上一个进程的虚拟地址对应的物理地址，所以必须将缓存清空，这个清空过程会产生开销。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="tlb">TLB<a href="#tlb" class="hash-link" aria-label="Direct link to TLB" title="Direct link to TLB">​</a></h3>
<p>TLB是对页表翻译结果的缓存。</p>
<p><img decoding="async" loading="lazy" alt="TLB" src="/assets/images/TLB-98112f6c97545f767c785dbd857fe313.png" width="1142" height="687" class="img_ev3q"></p>
<p>TLB分为TLBT（tag）和TLBI（index）两个部分，缓存分为tag（CT）、index（CI）和offset（CO）三个部分。TLB对应虚拟地址数（VPN），缓存对应完整的物理地址。</p>
<p><img decoding="async" loading="lazy" alt="TLB and Cache" src="/assets/images/TLB and Cache-da406e25fff4bfde82c1ba78664518cb.png" width="1496" height="860" class="img_ev3q"></p>
<p>具体来说，TLBI标识了TLB存在哪一行中，然后遍历这一行，找到对应的tag。如果valid位为1，就说明对应的PN有效，PN和VPP组合得到PA。PA按顺序拆分成tag、index和offset。</p>
<p>通过cache索引时，遍历的顺序为index-&gt;tag-&gt;offset。如果在对应的index中找到的tag和地址中的tag相等，且valid位为1，就在对应的offset找到了缓存数据。</p>
<p>TLBI的位数对应组数。如果TLB共有16个entries，且是4路组相连的，就说明每组有四个数据，即共有16/4 = 4组，TLBI需要2位。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="多级页表">多级页表<a href="#多级页表" class="hash-link" aria-label="Direct link to 多级页表" title="Direct link to 多级页表">​</a></h3>
<p>每个进程都需要一个独立的页表。如果采用单级页表设计，会导致页表占用了大量内存。而每个页表中可能只有几页用到。</p>
<p>以二级页表为例。在2级页表中，第一级页表中的每一项指向第二级页表的起始地址，二级页表中指向实际的物理地址。</p>
<p>现代CPU要求64位地址中，高16位的数字必须全零或全一，有效地址只有48位，且这些高位的值和第48位相等。如果这些位为1，则这部分是内核虚拟地址，否则是用户态虚拟地址。不同进 程的内核态虚拟内存内容相同。实际<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span></span></span></span></span></span></span></span>个地址中，有一部分是非法的。硬件规定每个页表占用一个4K物理页，每个页表项占据8个字节，每个页表页有512个页表项。</p>
<p>多级页表中，TLB中存储的仍然是实际的物理地址。虚拟地址中的虚拟页号部分存储了每一级对应哪个页表项。除最后一级外，页表中存储的地址为下一级页表的起始地址（第一级起始地址存放在CR3中）。每个页表项中的地址都是物理地址。</p>
<p>若地址共为64位，在四级页表中，48-63位全0/全1，12-47位每部分9位（9位对应512个页表项）存储页表索引，0-11位共12位存储业内偏移。注意2、3...页表均为页表页，每个页表页分配时最少需要4K。对于16K页表来说，最后的第四级页表大小为4K，有512个页表项，业内偏移为12位，则能记录的地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>512</mn><mo>×</mo><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>21</mn></msup></mrow><annotation encoding="application/x-tex">512 \times 2 ^ {12} = 2^{21}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">512</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">21</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="core-i7">Core i7<a href="#core-i7" class="hash-link" aria-label="Direct link to Core i7" title="Direct link to Core i7">​</a></h3>
<p>Core i7中，支持48位（256T）的虚拟地址空间和52位（6PB）的物理地址空间。兼容性模式支持32位虚拟和物理地址空间。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vipt">VIPT<a href="#vipt" class="hash-link" aria-label="Direct link to VIPT" title="Direct link to VIPT">​</a></h3>
<p>VA分为36位的VPN和12位的VPO，对应的PA分为CT、CI和CO。VIPT同时综合了VIVT和PIPT的优点，同时将虚拟地址发送给缓存和MMU。缓存读取到对应的index，然后等待MMU翻译出物理的tag，对应找到数值。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="linux实现">Linux实现<a href="#linux实现" class="hash-link" aria-label="Direct link to Linux实现" title="Direct link to Linux实现">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存分配概念">内存分配概念<a href="#内存分配概念" class="hash-link" aria-label="Direct link to 内存分配概念" title="Direct link to 内存分配概念">​</a></h3>
<p>Linux通过将虚拟内存和物理内存关联来进行初始化。虚拟内存的初值是物理内存中的内容。虚拟内存可能关联普通的文件，初值为文件内容；也可能关联匿名文件，初值全部为零。例如，堆、栈、.bss关联匿名文件，因为堆、栈可以按需分配，不与实际文件相关联。</p>
<p>swap file是操作系统分配的一个区域，用来交换内存中更改过的内容。</p>
<p>按照按需分配的思想，虚拟页创建时就被标记，但只有它真正被使用时，才会实际地与物理页建立关联，即在页表中填写相应的映射。</p>
<p>执行execve命令时，首先将所有vm结构体和页表释放。然后，为新的程序创建vm和页表（根据代码等的elf），设置初始值、是否能访问等（共享库也是私有的）。最后设置PC（同样存储在elf中），开始执行，Linux会按需进行分页。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="用户态内存分配">用户态内存分配<a href="#用户态内存分配" class="hash-link" aria-label="Direct link to 用户态内存分配" title="Direct link to 用户态内存分配">​</a></h3>
<div class="language-C language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// start是应用程序指定的虚拟起始地址，不一定被系统启用</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token function" style="color:#d73a49">mmap</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">start</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> len</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> prot</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> flags</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> fd</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> offset</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>使用 <code>mmap</code> 可以更快地复制文件。在 <code>read</code> 时，如果文件内容已被缓存，操作系统会创建对应的虚拟内存，将其与另一个物理内存建立连接，再将内存中的内容复制。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="fork">fork<a href="#fork" class="hash-link" aria-label="Direct link to fork" title="Direct link to fork">​</a></h3>
<p>在复制时，默认不复制物理地址内容，而是让两个虚拟地址指向一个物理地址。在发生写操作时，才会复制改变后的内容。这种设计模式会让fork的性能产生很大的提升。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="替换策略">替换策略<a href="#替换策略" class="hash-link" aria-label="Direct link to 替换策略" title="Direct link to 替换策略">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="基本参数">基本参数<a href="#基本参数" class="hash-link" aria-label="Direct link to 基本参数" title="Direct link to 基本参数">​</a></h3>
<p>hit rate指在一定次数的查询中，查到的次数和总数之比。</p>
<p>如果已知了要访问的所有内存，则一定能据此设计出一个最优解，将不同策略的hit rate和最优解的hit rate比较，则能得出不同策略的优劣。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="fifo">FIFO<a href="#fifo" class="hash-link" aria-label="Direct link to FIFO" title="Direct link to FIFO">​</a></h3>
<p>换出时，优先唤出最早换入的页。</p>
<p>这种策略会导致Belady异常。直观上来说，如果可分配的页面数增多，hit rate应该上升；但在FIFO策略中，hit rate有可能反而下降。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="random-replacement">Random Replacement<a href="#random-replacement" class="hash-link" aria-label="Direct link to Random Replacement" title="Direct link to Random Replacement">​</a></h3>
<p>随机换出可以带来可以接受的性能。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="lru">LRU<a href="#lru" class="hash-link" aria-label="Direct link to LRU" title="Direct link to LRU">​</a></h3>
<p>LRU是least recently used的缩写。它的思想是每次换出最久远使用的页。类似的思路还有LFU，换出使用频率最低的页，但是相对而言LRU更好。但是事实上，LRU无法真正实现，因为使用时间不会被MMU记录，只能实现LRU的近似。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="时钟算法">时钟算法<a href="#时钟算法" class="hash-link" aria-label="Direct link to 时钟算法" title="Direct link to 时钟算法">​</a></h3>
<p>时钟算法的思想是通过access bit模拟寻找最久远的页。</p>
<p>时钟算法将物理页排布成一圈，从任意一个地址开始。最开始每一块都为空，按顺序将每一块内容放在内存里。在放满时，如果需要换出，时钟遍历物理页，如果access bit为1，将其置为0，然后继续，直到找到access bit为0的位置。</p>
<p><img decoding="async" loading="lazy" alt="clock algorithm" src="/assets/images/clock algorithm-9c867dd3afb5dd3f5b3ead34deaa7719.png" width="667" height="478" class="img_ev3q"></p>
<p>操作系统通过反向映射（reference mapping）记录哪些物理内存被访问。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/CSAPP and SJTU ICS/25 Virtual Memory.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#虚拟内存" class="table-of-contents__link toc-highlight">虚拟内存</a><ul><li><a href="#访问内存" class="table-of-contents__link toc-highlight">访问内存</a></li><li><a href="#分页" class="table-of-contents__link toc-highlight">分页</a></li><li><a href="#内存管理" class="table-of-contents__link toc-highlight">内存管理</a></li><li><a href="#内存隔离" class="table-of-contents__link toc-highlight">内存隔离</a></li></ul></li><li><a href="#地址翻译" class="table-of-contents__link toc-highlight">地址翻译</a><ul><li><a href="#基本信息" class="table-of-contents__link toc-highlight">基本信息</a></li><li><a href="#缓存" class="table-of-contents__link toc-highlight">缓存</a></li><li><a href="#tlb" class="table-of-contents__link toc-highlight">TLB</a></li><li><a href="#多级页表" class="table-of-contents__link toc-highlight">多级页表</a></li><li><a href="#core-i7" class="table-of-contents__link toc-highlight">Core i7</a></li><li><a href="#vipt" class="table-of-contents__link toc-highlight">VIPT</a></li></ul></li><li><a href="#linux实现" class="table-of-contents__link toc-highlight">Linux实现</a><ul><li><a href="#内存分配概念" class="table-of-contents__link toc-highlight">内存分配概念</a></li><li><a href="#用户态内存分配" class="table-of-contents__link toc-highlight">用户态内存分配</a></li><li><a href="#fork" class="table-of-contents__link toc-highlight">fork</a></li></ul></li><li><a href="#替换策略" class="table-of-contents__link toc-highlight">替换策略</a><ul><li><a href="#基本参数" class="table-of-contents__link toc-highlight">基本参数</a></li><li><a href="#fifo" class="table-of-contents__link toc-highlight">FIFO</a></li><li><a href="#random-replacement" class="table-of-contents__link toc-highlight">Random Replacement</a></li><li><a href="#lru" class="table-of-contents__link toc-highlight">LRU</a></li><li><a href="#时钟算法" class="table-of-contents__link toc-highlight">时钟算法</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li><li class="footer__item"><a class="footer__link-item" href="/blog">About Me</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.co/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow (to do)<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/key4127" target="_blank" rel="noopener noreferrer" class="footer__link-item">My GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>